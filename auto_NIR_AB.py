import astropy.io.ascii as asci
import numpy as np
import sys, os
from astropy.coordinates import SkyCoord
import astropy.units as u
from astropy import table

"""
This script takes the .pypeit file generated by pypeit_setup and assign
bkg_id and calib based on the assumption that data are taken in the 
AB pattern. Here, ABBA or ABAB doesn't matter, as long as they're in sets
of two files that can subtract each other
"""

def make_ABBA(list):
    "Given a list, assign the indices into two lists of A and B positions"
    if len(list) % 2 == 0: #even number only
        BA = 0
        a = []
        b = []
        for ind in range(len(list) // 2):
            if BA == 0:
                a += [list[2 * ind]]
                b += [list[2 * ind + 1]]
                BA = 1
            else:
                a += [list[2 * ind + 1]]
                b += [list[2 * ind]]
                BA = 0
        return np.array(a), np.array(b)
    else:
        print("Input must be of even length.")
        return None

files = sys.argv[1]

#Copy the file as a backup
os.system('cp %s %s.backup'%(files,files))

#Open a new pypeit file to write the header to. 
new_file = open('ABBA_%s'%files, 'w')

#Find where data start
f = open(files, 'r')
header_line = None
valid_line = 0
for line in f:
    if len(line.strip()) > 0:
        # print(line.strip())
        if line.strip()[0] != '#':
            valid_line += 1
            if '|' in line and header_line is None:
                header_line = valid_line
                break #break here so we only include the preamble and not the "data end" line at the end.
            elif '|' not in line:
                new_file.write(line)
                if "spectrograph = keck_nires" in line:
                    ###############################IMPORTANT. This forces the object ID algorithm to only find
                    #one brightest object with an SNR threshold of 5 sigma. 
                    new_file.write("[reduce]\n\t[[findobj]]\n\t\tmaxnumber_sci = 1\n\t\tsnr_thresh = 5.0\n")
        else:
            new_file.write(line)
    else:
        new_file.write(line)

new_file.close()

# print(header_line)

giant_table = asci.read(files, format = 'fixed_width', header_start=header_line-1, data_start=header_line)
#remove "data end"
giant_table = giant_table[:-1]

# print(giant_table)

#########assign all HIP stars to "standard"##########################
#########set calib to 'all' for flats################################
max_comb_id = np.nanmax(giant_table['comb_id'])

#Set calibration indices
for i in giant_table:
    if 'HIP' in i['target']:
        i['frametype'] = 'standard'
        i['comb_id'] = max_comb_id + 1
        max_comb_id += 1
    if 'science' in i['frametype']:
        i['calib'] = i['comb_id'] 
    if 'pixelflat,trace' in i['frametype']:
        i['calib'] = 'all'
# print(giant_table)


#########Pair things up in AB or BA pairs############################
for ind, i in enumerate(giant_table):
    if ('standard' in i['frametype']) | ('science' in i['frametype']): #do ABBA
        if i['bkg_id'] == -1 and giant_table[ind+1]['target'].strip() == i['target'].strip(): 
            giant_table[ind]['bkg_id'] = giant_table[ind+1]['comb_id'] #Set B as background for A
            giant_table[ind+1]['bkg_id'] = i['comb_id'] #Set A as background for B
        elif i['bkg_id'] != -1:
            pass
        else:
            print(i['bkg_id'], giant_table[ind+1]['target'], i['target'],  giant_table[ind+1]['target']==i['target'])
            print("File %s does not have a subtraction pair. Check .pypeit file."%(i['filename']))

#########Lastly, find an appropriate calibration for telluric. 

####For science frames with <=180 s exposure, combine A's and B's for calibrations first, otherwise 
####wavelength solution fails


unique_science = table.unique(giant_table[giant_table['frametype'] == 'arc,science,tilt'], 'target')
sci_coord = SkyCoord(ra = unique_science['ra']*u.deg, dec = unique_science['dec']*u.deg)
unique_standard = table.unique(giant_table[giant_table['frametype'] == 'standard'], 'target')
std_coord = SkyCoord(ra = unique_standard['ra']*u.deg, dec = unique_standard['dec']*u.deg)

for sci in unique_science:
    exp_times = list(set(giant_table['exptime'][giant_table['target']==sci['target']]))
    if (len(exp_times) == 1) & (exp_times[0] <= 180) : #one exposure times, < 180s
        # print(giant_table['target', 'calib', 'comb_id'][giant_table['target']==sci['target']])
        idx = np.where(giant_table['target']==sci['target'])[0]
        if (np.sum(giant_table['target']==sci['target']) >=4) & (np.sum(giant_table['target']==sci['target']) % 2 == 0): #ABBA
            # giant_table['calib'][idx[2]] = giant_table['calib'][idx[1]]
            # giant_table['calib'][idx[3]] = giant_table['calib'][idx[0]]
            As, Bs = make_ABBA(idx)
            giant_table['calib'][As] = giant_table['calib'][As[0]] #set all A's to the same calib id
            giant_table['calib'][Bs] = giant_table['calib'][Bs[0]] #set all B's to the same calib id

        # print(giant_table['target', 'calib', 'comb_id'][giant_table['target']==sci['target']])

#redo unique_science to update the calib id
unique_science = table.unique(giant_table[giant_table['frametype'] == 'arc,science,tilt'], 'target')

# print(unique_science)
# print(unique_standard)

print("Check if the following science - telluric association is correct.")
res = sci_coord.match_to_catalog_sky(std_coord)[0]
# print(res)
for ind, i in enumerate(unique_science):
    print(
        unique_science[ind]["target"],
        # sci_coord[ind].to_string('hmsdms'),
        unique_standard[res[ind]]["target"],
        # std_coord[res[ind]].to_string('hmsdms'),
    )

for ind, i in enumerate(unique_science):
    science_id = np.array(giant_table[giant_table['target'] == i['target']]['calib'])
    telluric_name = unique_standard[res[ind]]["target"]
    # print(i['target'], telluric_name)
    # print(np.where(giant_table['target'] == telluric_name)[0])
    #if science is in ABBA
    if len(np.where(giant_table['target'] == telluric_name)[0]) <=  len(science_id):
        for jnd, j in enumerate(np.where(giant_table['target'] == telluric_name)[0]):
            giant_table[j]['calib'] = science_id[jnd]
    #if science is in AB, but telluric is ABBA
    elif (len(np.where(giant_table['target'] == telluric_name)[0])==4)  & (len(science_id)==2):
        science_id = np.concatenate([science_id , science_id[::-1]])
        for jnd, j in enumerate(np.where(giant_table['target'] == telluric_name)[0]):
            giant_table[j]['calib'] = science_id[jnd]
    #Two sets of Telluric ABBA, ABBA
    elif len(np.where(giant_table['target'] == telluric_name)[0]) ==  2*len(science_id):
        # print(science_id)
        science_id = np.concatenate([science_id , science_id])
        # print(science_id)
        for jnd, j in enumerate(np.where(giant_table['target'] == telluric_name)[0]):
            giant_table[j]['calib'] = science_id[jnd]       
    else:
        print("Manually check the calib_id of %s"%(telluric_name))

# print(giant_table)
giant_table.write('temp.pypeit', format = 'ascii.fixed_width', \
    delimiter = '|', bookend=False, comment=False, overwrite = True)

#concatenate the table to the new header
os.system('cat temp.pypeit >> ABBA_%s'%files)
os.system('echo "data end" >> ABBA_%s'%files)
os.system('rm temp.pypeit')

